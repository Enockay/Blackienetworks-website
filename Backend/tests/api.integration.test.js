const request = require('supertest');
const mongoose = require('mongoose');
const app = require('../app');
const AccessToken = require('../models/accessToken');
const Notification = require('../models/notification');
const NotificationTemplate = require('../models/notificationTemplate');
const Booking = require('../models/booking');

// Mock notification service to avoid actual API calls
jest.mock('../utils/notificationService', () => ({
  sendNotification: jest.fn().mockResolvedValue({
    success: true,
    notificationId: 'mock-notification-id',
    messageId: 'mock-message-id',
    status: 'sent',
    channel: 'email'
  }),
  sendBulkNotifications: jest.fn().mockResolvedValue({
    total: 2,
    successful: 2,
    failed: 0,
    results: [
      { success: true, notificationId: 'notif-1' },
      { success: true, notificationId: 'notif-2' }
    ]
  })
}));

const { sendOTPViaEmail, sendOTPViaSMS, sendOTPViaBoth, verifyOTP } = require('../utils/otpService');

// Mock email service
jest.mock('../utils/emailService', () => ({
  sendBookingConfirmation: jest.fn().mockResolvedValue({
    body: { messageId: 'email-confirmation-id' }
  }),
  sendAdminNotification: jest.fn().mockResolvedValue({
    body: { messageId: 'admin-notification-id' }
  })
}));

describe('API Integration Tests', () => {
  let testToken;
  let testTokenId;
  const testPhoneNumber = '+254796869402';
  const testEmail = 'enockaymwema@gmail.com';

  beforeAll(async () => {
    // Connect to test database
    const MONGODB_TEST = process.env.MONGODB;
    await mongoose.connect(MONGODB_TEST);
    
    // Create a test access token
    const token = new AccessToken({
      name: 'Test Token',
      description: 'Token for API tests',
      allowedChannels: ['email', 'sms'],
      rateLimit: 10000
    });
    // Save token - token is auto-generated by default function
    await token.save();
    testTokenId = token._id.toString();
    
    // Access token directly from the mongoose document (before toJSON transformation)
    // The token field is available on the document object
    const actualToken = token.token;
    
    testToken = {
      _id: token._id,
      token: actualToken, // Token from the saved document
      name: token.name,
      allowedChannels: token.allowedChannels
    };
    
    // Verify we have a token
    if (!testToken.token) {
      throw new Error('Failed to get access token for tests');
    }
  });

  afterAll(async () => {
    // Clean up test data
    await AccessToken.deleteMany({});
    await Notification.deleteMany({});
    await NotificationTemplate.deleteMany({});
    await Booking.deleteMany({});
    await mongoose.connection.close();
  });

  beforeEach(async () => {
    // Clear notifications and bookings before each test
    await Notification.deleteMany({});
    await Booking.deleteMany({});
  });

  describe('Health Check', () => {
    it('GET /health should return 200 with health status', async () => {
      const response = await request(app)
        .get('/health')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.status).toBe('OK');
      expect(response.body.timestamp).toBeDefined();
    });
  });

  describe('Token Management API', () => {
    it('POST /api/tokens should create a new access token', async () => {
      const response = await request(app)
        .post('/api/tokens')
        .send({
          name: 'API Test Token',
          description: 'Token for testing',
          allowedChannels: ['email', 'sms'],
          rateLimit: 5000
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.token).toBeDefined();
      expect(response.body.data.name).toBe('API Test Token');
      expect(response.body.data.allowedChannels).toEqual(['email', 'sms']);
    });

    it('GET /api/tokens should list all tokens', async () => {
      const response = await request(app)
        .get('/api/tokens')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.tokens).toBeInstanceOf(Array);
      expect(response.body.data.total).toBeGreaterThan(0);
    });

    it('GET /api/tokens/:id should get a specific token', async () => {
      const response = await request(app)
        .get(`/api/tokens/${testTokenId}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.token.id).toBe(testTokenId);
    });

    it('PUT /api/tokens/:id should update a token', async () => {
      const response = await request(app)
        .put(`/api/tokens/${testTokenId}`)
        .send({
          name: 'Updated Test Token',
          isActive: false
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.token.name).toBe('Updated Test Token');
      expect(response.body.data.token.isActive).toBe(false);
    });

    it('DELETE /api/tokens/:id should delete a token', async () => {
      // Create a token to delete
      const tokenToDelete = new AccessToken({
        name: 'Token to Delete',
        allowedChannels: ['email']
      });
      const savedToken = await tokenToDelete.save();

      const response = await request(app)
        .delete(`/api/tokens/${savedToken._id.toString()}`)
        .expect(200);

      expect(response.body.success).toBe(true);
    });
  });

  describe('Notification API', () => {
    it('POST /api/notifications/send should send email notification', async () => {
      const response = await request(app)
        .post('/api/notifications/send')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          channel: 'email',
          recipient: testEmail,
          subject: 'Test Email',
          message: '<h1>Test Email Content</h1>',
          recipientName: 'Test User'
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.notificationId).toBeDefined();
      expect(response.body.data.channel).toBe('email');
    });

    it('POST /api/notifications/send should send SMS notification', async () => {
      const response = await request(app)
        .post('/api/notifications/send')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          channel: 'sms',
          recipient: testPhoneNumber,
          message: 'Test SMS message'
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.channel).toBe('sms');
    });

    it('POST /api/notifications/bulk should send bulk notifications', async () => {
      const response = await request(app)
        .post('/api/notifications/bulk')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          notifications: [
            {
              channel: 'email',
              recipient: testEmail,
              subject: 'Bulk Test 1',
              message: 'First bulk message'
            },
            {
              channel: 'sms',
              recipient: testPhoneNumber,
              message: 'Second bulk message'
            }
          ]
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.total).toBe(2);
      expect(response.body.data.successful).toBe(2);
    });

    it('GET /api/notifications should list notifications', async () => {
      // First create a notification
      await request(app)
        .post('/api/notifications/send')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          channel: 'email',
          recipient: testEmail,
          subject: 'List Test',
          message: 'Test message'
        });

      const response = await request(app)
        .get('/api/notifications')
        .set('Authorization', `Bearer ${testToken.token}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.notifications).toBeInstanceOf(Array);
    });

    it('GET /api/notifications/:id should get a specific notification', async () => {
      // Create a notification first
      const createResponse = await request(app)
        .post('/api/notifications/send')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          channel: 'email',
          recipient: testEmail,
          subject: 'Get Test',
          message: 'Test message'
        });

      const notificationId = createResponse.body.data.notificationId;

      const response = await request(app)
        .get(`/api/notifications/${notificationId}`)
        .set('Authorization', `Bearer ${testToken.token}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.notification).toBeDefined();
    });

    it('GET /api/notifications/stats/summary should get statistics', async () => {
      const response = await request(app)
        .get('/api/notifications/stats/summary')
        .set('Authorization', `Bearer ${testToken.token}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.summary).toBeDefined();
      expect(response.body.data.summary.total).toBeDefined();
    });
  });

  describe('Booking API', () => {
    it('POST /api/bookings/book/public should create a public booking', async () => {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 7);
      const dateStr = futureDate.toISOString().split('T')[0];

      const response = await request(app)
        .post('/api/bookings/book/public')
        .send({
          name: 'Test User',
          email: testEmail,
          phone: testPhoneNumber,
          service: 'Web Development',
          date: dateStr,
          time: '10:00',
          description: 'Test booking description'
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.booking).toBeDefined();
      expect(response.body.booking.name).toBe('Test User');
    });

    it('GET /api/bookings should list all bookings', async () => {
      const response = await request(app)
        .get('/api/bookings')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.bookings).toBeInstanceOf(Array);
    });
  });

  describe('Template API', () => {
    let templateId;

    it('POST /api/templates should create a template', async () => {
      const response = await request(app)
        .post('/api/templates')
        .send({
          name: 'test_email_template',
          description: 'Test email template',
          channel: 'email',
          subject: 'Test Subject {{name}}',
          body: 'Hello {{name}}, this is a test message.',
          variables: ['name']
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.template).toBeDefined();
      // Template ID can be _id or id depending on toJSON transform
      templateId = response.body.data.template._id || response.body.data.template.id;
      expect(templateId).toBeDefined();
      templateId = templateId.toString();
      expect(templateId).toBeTruthy();
    });

    it('GET /api/templates should list all templates', async () => {
      const response = await request(app)
        .get('/api/templates')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.templates).toBeInstanceOf(Array);
    });

    it('GET /api/templates/:id should get a specific template', async () => {
      if (!templateId) {
        // Skip if template wasn't created
        return;
      }
      
      const response = await request(app)
        .get(`/api/templates/${templateId}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.template).toBeDefined();
    });

    it('GET /api/templates/:id/preview should preview a template', async () => {
      if (!templateId) {
        // Skip if template wasn't created
        return;
      }
      
      const response = await request(app)
        .get(`/api/templates/${templateId}/preview`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.template).toBeDefined();
      expect(response.body.data.template.body).toContain('[Sample name]');
    });

    it('PUT /api/templates/:id should update a template', async () => {
      if (!templateId) {
        // Skip if template wasn't created
        return;
      }
      
      const response = await request(app)
        .put(`/api/templates/${templateId}`)
        .send({
          description: 'Updated description',
          isActive: false
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.template.description).toBe('Updated description');
    });

    it('DELETE /api/templates/:id should delete a template', async () => {
      if (!templateId) {
        // Skip if template wasn't created
        return;
      }
      
      const response = await request(app)
        .delete(`/api/templates/${templateId}`)
        .expect(200);

      expect(response.body.success).toBe(true);
    });
  });

  describe('OTP API', () => {
    it('POST /api/otp/send/email should send OTP via email', async () => {
      const response = await request(app)
        .post('/api/otp/send/email')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          email: testEmail,
          recipientName: 'Test User'
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.email).toBe(testEmail);
      expect(response.body.data.expiresInMinutes).toBe(10);
      expect(response.body.data.otp).toBeDefined(); // In test environment
    });

    it('POST /api/otp/send/sms should send OTP via SMS using test phone number', async () => {
      const response = await request(app)
        .post('/api/otp/send/sms')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          phoneNumber: testPhoneNumber
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.phoneNumber).toBe(testPhoneNumber);
      expect(response.body.data.expiresInMinutes).toBe(10);
      expect(response.body.data.otp).toBeDefined(); // In test environment
    });

    it('POST /api/otp/send/both should send OTP via both email and SMS', async () => {
      const response = await request(app)
        .post('/api/otp/send/both')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          email: testEmail,
          phoneNumber: testPhoneNumber,
          recipientName: 'Test User'
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.email).toBe(testEmail);
      expect(response.body.data.phoneNumber).toBe(testPhoneNumber);
      expect(response.body.data.emailNotification).toBeDefined();
      expect(response.body.data.smsNotification).toBeDefined();
      expect(response.body.data.otp).toBeDefined(); // In test environment
    });

    it('POST /api/otp/verify should verify OTP correctly', async () => {
      // First send OTP
      const sendResponse = await request(app)
        .post('/api/otp/send/email')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          email: testEmail
        });

      const otp = sendResponse.body.data.otp;

      // Then verify it
      const verifyResponse = await request(app)
        .post('/api/otp/verify')
        .send({
          identifier: testEmail,
          otp: otp
        })
        .expect(200);

      expect(verifyResponse.body.success).toBe(true);
      expect(verifyResponse.body.data.verified).toBe(true);
    });

    it('POST /api/otp/verify should reject invalid OTP', async () => {
      // First send OTP
      await request(app)
        .post('/api/otp/send/email')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          email: testEmail
        });

      // Try to verify with wrong OTP
      const verifyResponse = await request(app)
        .post('/api/otp/verify')
        .send({
          identifier: testEmail,
          otp: '000000'
        })
        .expect(400);

      expect(verifyResponse.body.success).toBe(false);
      expect(verifyResponse.body.error).toBe('INVALID_OTP');
      expect(verifyResponse.body.data.verified).toBe(false);
    });

    it('POST /api/otp/send/sms should work with test phone number 254796869402', async () => {
      const phoneWithCountryCode = '+254796869402';
      
      const response = await request(app)
        .post('/api/otp/send/sms')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          phoneNumber: phoneWithCountryCode
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.phoneNumber).toBe(phoneWithCountryCode);
      expect(response.body.data.otp).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should return 404 for non-existent routes', async () => {
      const response = await request(app)
        .get('/api/nonexistent')
        .expect(404);

      expect(response.body.success).toBe(false);
    });

    it('should return 401 for missing authorization token', async () => {
      const response = await request(app)
        .post('/api/notifications/send')
        .send({
          channel: 'email',
          recipient: testEmail,
          message: 'Test'
        })
        .expect(401);

      expect(response.body.success).toBe(false);
    });

    it('should return 400 for validation errors', async () => {
      if (!testToken || !testToken.token) {
        // Skip if token wasn't created
        return;
      }
      
      const response = await request(app)
        .post('/api/notifications/send')
        .set('Authorization', `Bearer ${testToken.token}`)
        .send({
          channel: 'invalid_channel',
          recipient: testEmail,
          message: 'Test'
        })
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe('VALIDATION_ERROR');
    });
  });
});

